---
layout: default
title: V1.0 API - SAF Physics
---

# V1.0 API Reference

**SAF Physics Fundamentals - 12 GPU Kernels**

---

## RKKY Interlayer Coupling

### EnableRKKYCoupling()

Enable RKKY exchange coupling between magnetic layers.

**Physics:**
```
H_RKKY = J(t_s) × m_other / (μ₀ × Ms × t)
J(t_s) = J₀ × sin(2π × t_s / λ) / (t_s / λ)²
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `RKKYStrength` | float | J/m² | 0 | Coupling strength J₀ |
| `RKKYPeriod` | float | m | 1e-9 | Oscillation period λ |
| `RKKYSpacerThickness` | float | m | 1e-9 | Spacer layer thickness t_s |

**Usage:**
```go
EnableRKKYCoupling()
SetRKKYStrength(-0.5e-3)       // Antiferromagnetic coupling
SetRKKYPeriod(0.8e-9)          // 0.8 nm period
SetRKKYSpacerThickness(0.9e-9) // 0.9 nm spacer
```

**Output Quantities:**
- `E_RKKY` - RKKY coupling energy (J)
- `B_RKKY` - RKKY effective field (T)

---

## Spin-Orbit Torque (SOT)

### EnableSOT()

Enable spin-orbit torque from spin Hall effect in heavy metal underlayer.

**Physics:**
```
τ_DL = γ × θ_SH × ℏ × J / (2 × e × Ms × t) × (m × (m × σ))
τ_FL = γ × θ_SH × ℏ × J / (2 × e × Ms × t) × (m × σ)
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `SOT_theta_SH` | float | - | 0 | Spin Hall angle θ_SH |
| `SOT_J` | vector | A/m² | (0,0,0) | Charge current density |
| `SOT_xi` | float | - | 0 | Field-like torque ratio |
| `SOT_pol` | vector | - | (0,1,0) | Spin polarization direction |

**Usage:**
```go
EnableSOT()
SOT_theta_SH = 0.3              // Pt spin Hall angle
SOT_J = Vector(1e12, 0, 0)      // 1 TA/m² along x
SOT_xi = 0.1                    // Small field-like component
SOT_pol = Vector(0, 1, 0)       // y-polarized spins
```

---

## Spin-Transfer Torque (STT)

### EnableSTT()

Enable spin-transfer torque for current-perpendicular-to-plane geometry.

**Physics:**
```
τ_STT = -γ × a_J × (m × (m × p)) - γ × b_J × (m × p)
a_J = ℏ × J × P / (2 × e × Ms × t)
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `STT_J` | float | A/m² | 0 | Current density (perpendicular) |
| `STT_P` | float | - | 0.5 | Spin polarization |
| `STT_Lambda` | float | - | 1 | Slonczewski Λ parameter |
| `STT_eps` | float | - | 0 | Secondary spin-torque parameter |
| `STT_fixedLayer` | vector | - | (1,0,0) | Fixed layer magnetization |

**Usage:**
```go
EnableSTT()
STT_J = 1e11                       // 100 GA/m²
STT_P = 0.7                        // 70% polarization
STT_Lambda = 2                     // Asymmetry parameter
STT_fixedLayer = Vector(1, 0, 0)   // Fixed along +x
```

---

## Thermal Fluctuations

### EnableThermalField()

Enable stochastic thermal field following Langevin dynamics.

**Physics:**
```
H_therm = η × √(2 × α × k_B × T / (γ × μ₀ × Ms × V × Δt))
```

Where η is a Gaussian random number (mean=0, variance=1).

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `Temp` | float | K | 0 | Temperature |
| `ThermalSeed` | int | - | 0 | Random number seed |

**Usage:**
```go
EnableThermalField()
Temp = 300                  // Room temperature
ThermalSeed = 12345         // Reproducible random sequence

// Temperature can be region-specific
Temp.SetRegion(1, 350)      // Heated region
```

---

## Voltage-Controlled Magnetic Anisotropy (VCMA)

### EnableVCMA()

Enable voltage-dependent perpendicular anisotropy modulation.

**Physics:**
```
K_eff = K_u - ξ × V / t
H_VCMA = 2 × K_eff × (m · u) × u / (μ₀ × Ms)
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `VCMA_xi` | float | J/(V·m) | 0 | VCMA coefficient ξ |
| `VCMA_V` | float | V | 0 | Applied voltage |
| `VCMA_thickness` | float | m | 1e-9 | Magnetic layer thickness |

**Usage:**
```go
EnableVCMA()
VCMA_xi = 30e-15           // 30 fJ/(V·m)
VCMA_V = 1.0               // 1 V applied
VCMA_thickness = 1e-9      // 1 nm CoFeB

// Dynamic voltage
VCMA_V = Sin(2*pi*1e9*t)   // 1 GHz oscillation
```

---

## Oersted Field

### EnableOerstedField()

Calculate Oersted field from current distribution using Biot-Savart law.

**Physics:**
```
B(r) = (μ₀ / 4π) × ∫ J(r') × (r - r') / |r - r'|³ dV'
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `OerstedCurrent` | vector | A/m² | (0,0,0) | Current density distribution |

**Usage:**
```go
EnableOerstedField()
OerstedCurrent = Vector(1e12, 0, 0)  // 1 TA/m² along x

// Current in specific region
OerstedCurrent.SetRegion(2, Vector(1e12, 0, 0))
```

---

## Topological Charge

### ComputeTopologicalCharge()

Calculate skyrmion number (topological charge) in each layer.

**Physics:**
```
Q = (1/4π) × ∫∫ m · (∂m/∂x × ∂m/∂y) dx dy
```

**Usage:**
```go
// Add to output table
TableAdd(TopologicalCharge)

// Save during simulation
Run(1e-9)
TableSave()
```

**Output:**
- Returns integer skyrmion count for each z-layer
- Q = +1 for Néel skyrmion with core up
- Q = -1 for Néel skyrmion with core down

---

## STDP Learning

### EnableSTDP()

Enable spike-timing-dependent plasticity for synaptic weight updates.

**Physics:**
```
ΔW = A+ × exp(-Δt/τ+)  if Δt > 0 (pre before post)
ΔW = -A- × exp(Δt/τ-)  if Δt < 0 (post before pre)
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `STDP_Aplus` | float | - | 0.01 | Potentiation amplitude |
| `STDP_Aminus` | float | - | 0.012 | Depression amplitude |
| `STDP_tauPlus` | float | s | 20e-3 | Potentiation time constant |
| `STDP_tauMinus` | float | s | 20e-3 | Depression time constant |

**Usage:**
```go
EnableSTDP()
STDP_Aplus = 0.01
STDP_Aminus = 0.012
STDP_tauPlus = 20e-3
STDP_tauMinus = 20e-3

// Apply STDP update
ApplySTDP(preSpikeTimes, postSpikeTimes)
```

---

## Analog Weight Programming

### ProgramAnalogWeight()

Program analog synaptic weights in magnetic tunnel junction arrays.

**Physics:**
- Uses domain wall position to encode continuous weight values
- Weight ∝ domain wall position ∝ integrated current pulse

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `AnalogWeightMax` | float | - | 1.0 | Maximum weight value |
| `AnalogWeightMin` | float | - | 0.0 | Minimum weight value |
| `AnalogWeightLevels` | int | - | 256 | Number of discrete levels |

**Usage:**
```go
EnableAnalogWeights()
AnalogWeightLevels = 64       // 6-bit precision

// Program specific weight
ProgramWeight(region, targetValue)

// Read weight
currentWeight := ReadWeight(region)
```

---

## Region Sum Accumulation

### AccumulateRegionSums()

Compute accumulated sums over defined regions for post-processing.

**Usage:**
```go
// Define regions
DefRegion(1, Layer(0))
DefRegion(2, Layer(1))

// Get region averages
m1 := m.Region(1).Average()
m2 := m.Region(2).Average()
```

**Output:**
- Used internally for regional analysis
- Supports any scalar or vector quantity

---

## Complete V1.0 Example

```go
// SAF structure with RKKY coupling and thermal fluctuations
SetGridSize(256, 256, 2)
SetCellSize(4e-9, 4e-9, 1e-9)

// Material: CoFeB
Msat = 1.2e6
Aex = 15e-12
alpha = 0.01
Ku1 = 0.8e6
anisU = Vector(0, 0, 1)

// Define layers
DefRegion(1, Layer(0))   // Bottom FM
DefRegion(2, Layer(1))   // Top FM

// Enable SAF physics
EnableRKKYCoupling()
SetRKKYStrength(-0.8e-3)    // Strong AF coupling

// Add thermal noise
EnableThermalField()
Temp = 300

// Add SOT drive
EnableSOT()
SOT_theta_SH = 0.3
SOT_J = Vector(5e11, 0, 0)

// Initial antiparallel state
m.SetRegion(1, Uniform(1, 0, 0))
m.SetRegion(2, Uniform(-1, 0, 0))

// Output
TableAdd(E_total)
TableAdd(E_RKKY)
TableAdd(TopologicalCharge)
TableAutosave(10e-12)
AutoSave(m, 100e-12)

// Simulate 10 ns
Run(10e-9)
```

---

[Back to API Reference](/api/)

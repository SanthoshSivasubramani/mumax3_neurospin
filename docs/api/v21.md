---
layout: default
title: V2.1 API - Enhanced Solvers
---

# V2.1 API Reference

**Enhanced Solvers & Multiscale Implementations - 13 CPU Implementations**

All V1.0 and V2.0 features are included. This page documents additional V2.1 capabilities.

---

## Extended Spin Diffusion

### SolveSpinDiffusionExtended()

Extended Valet-Fert spin diffusion with SOR iterative solver.

**Physics:**
```
∇²μ_s = μ_s / λ_sf²
SOR: μ_s^(n+1) = (1-ω)μ_s^(n) + ω × [Laplacian term]
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `SpinDiffusionExt_lambda` | float | m | 10e-9 | Spin diffusion length |
| `SpinDiffusionExt_omega` | float | - | 1.5 | SOR relaxation parameter |
| `SpinDiffusionExt_maxIter` | int | - | 1000 | Maximum iterations |
| `SpinDiffusionExt_tol` | float | - | 1e-6 | Convergence tolerance |

**Usage:**
```go
EnableSpinDiffusionExtended()
SpinDiffusionExt_lambda = 8e-9
SpinDiffusionExt_omega = 1.7        // Over-relaxation
SpinDiffusionExt_maxIter = 2000

// Solve
SolveSpinDiffusionExtended()

// Get result
TableAdd(SpinAccumulation)
```

---

## Dynamic Reservoir Learning

### AdaptReservoirWeights()

Adaptive reservoir weight update with momentum and L2 regularization.

**Physics:**
```
v_t = β × v_{t-1} + (1-β) × ∇L
w_t = w_{t-1} - lr × (v_t + λ × w_{t-1})
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `ReservoirLearningRate` | float | - | 0.01 | Learning rate |
| `ReservoirMomentum` | float | - | 0.9 | Momentum coefficient β |
| `ReservoirWeightDecay` | float | - | 1e-4 | L2 regularization λ |

**Usage:**
```go
EnableDynamicReservoir()
ReservoirLearningRate = 0.001
ReservoirMomentum = 0.95
ReservoirWeightDecay = 1e-5

// Training loop
for epoch := 0; epoch < 100; epoch++ {
    // Forward pass through reservoir
    ReservoirInput(trainData)

    // Update weights
    AdaptReservoirWeights(targetOutput)
}
```

---

## Orange-Peel Coupling (GPU-Optimized)

### AddOrangePeelFieldGPU()

Néel orange-peel coupling from interface roughness with spatial convolution.

**Physics:**
```
F = (μ₀ × Ms² × π² × h²) / (2 × λ × t_s²) × exp(-2π√2 × t_s / λ)
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `OrangePeel_Frms` | float | m | 1e-9 | RMS roughness amplitude h |
| `OrangePeel_xi` | float | m | 10e-9 | Correlation length λ |

**Usage:**
```go
EnableOrangePeelGPU()
OrangePeel_Frms = 0.5e-9       // 0.5 nm roughness
OrangePeel_xi = 15e-9          // 15 nm correlation

// Field is automatically added to effective field
```

**Expected Output:**
- Ferromagnetic coupling between layers
- Magnitude: ~0.01-0.1 mJ/m² typically
- Decreases exponentially with spacer thickness

---

## Multi-Interface Atomistic Coupling

### CoupleAllAtomisticRegions()

Heisenberg exchange coupling between atomistic and continuum regions.

**Physics:**
```
J_eff = 2 × A_ex × a / (Ms × Ms)
E = -J × Σ S_i · S_j
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `AtomisticRegion_bounds` | []int | - | [] | Region boundaries [xmin,xmax,ymin,ymax,zmin,zmax] |
| `AtomisticRegion_oversampling` | int | - | 8 | Atomistic/continuum ratio |
| `AtomisticRegion_exchangeJ` | float | J | 0 | Exchange constant (0=auto) |

**Usage:**
```go
EnableAtomisticCoupling()

// Define atomistic region
AddAtomisticRegion(
    0, 64, 0, 64, 0, 1,  // Bounds
    8,                     // 8x oversampling
    0,                     // Auto-calculate J from Aex
)

// Coupling happens automatically at each timestep
```

---

## Grain Boundary Effects

### ApplyGrainBoundaryEffects()

Voronoi tessellation for polycrystalline microstructure.

**Physics:**
- Generates Voronoi grains
- Reduces exchange at boundaries: A_ex,boundary = A_ex × reduction_factor
- Optional random anisotropy per grain

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `GrainCount` | int | - | 100 | Number of grains |
| `GrainBoundaryReduction` | float | - | 0.5 | Exchange reduction at boundaries |
| `GrainAnisotropyVariation` | float | - | 0.1 | Random anisotropy (fraction) |
| `GrainSeed` | int | - | 0 | Random seed for reproducibility |

**Usage:**
```go
EnableGrainBoundaries()
GrainCount = 200
GrainBoundaryReduction = 0.3     // 70% reduction at boundaries
GrainAnisotropyVariation = 0.05  // 5% random K variation
GrainSeed = 12345

// Generate structure
GenerateVoronoiGrains(GrainCount)

// Visualize grains
Save(GrainMap)
```

**Expected Output:**
- Irregular domain walls pinned at grain boundaries
- Increased coercivity
- Distributed switching field

---

## Adaptive Oversampling

### ComputeOversamplingMask()

Gradient-based adaptive mesh refinement.

**Physics:**
```
grad_mag = √(|∇m|²)
level = 8 if grad > 4θ, 4 if grad > 2θ, 2 if grad > θ, else 1
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `OversamplingThreshold` | float | 1/m | 1e8 | Gradient threshold θ |
| `OversamplingMaxLevel` | int | - | 8 | Maximum refinement level |

**Usage:**
```go
EnableAdaptiveOversampling()
OversamplingThreshold = 5e7
OversamplingMaxLevel = 8

// Mask computed automatically
// Higher resolution near domain walls and skyrmions
Save(OversamplingMask)
```

---

## Dynamic Defects

### ApplyDefectPinning()

Point defect pinning for domain wall and skyrmion dynamics.

**Physics:**
```
H_pin = K_pin × m
K_pin = global_strength × local_strength × Ms
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `DefectStrength` | float | - | 0.1 | Global pinning strength |
| `DefectDensity` | float | - | 0.01 | Fraction of cells with defects |
| `DefectSeed` | int | - | 0 | Random seed |

**Usage:**
```go
EnableDynamicDefects()
DefectStrength = 0.2
DefectDensity = 0.05        // 5% defect density

// Generate random defects
GenerateRandomDefects(DefectDensity)

// Or set manually
SetDefectLocation(x, y, z, strength)

// Visualize
Save(DefectLocations)
```

---

## Correlated Roughness

### GenerateCorrelatedRoughness()

Spatially correlated surface roughness generation.

**Physics:**
```
H(k) = H_0(k) × exp(-k²ξ²/2)
```
Where H_0 is white noise and ξ is correlation length.

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `RoughnessAmplitude` | float | m | 1e-9 | RMS roughness |
| `RoughnessCorrelation` | float | m | 10e-9 | Correlation length ξ |
| `RoughnessSeed` | int | - | 0 | Random seed |

**Usage:**
```go
EnableCorrelatedRoughness()
RoughnessAmplitude = 0.8e-9
RoughnessCorrelation = 20e-9

// Generate roughness profile
GenerateCorrelatedRoughness()

// Apply to geometry
ApplyRoughnessToSurface(TopSurface)

// Visualize
Save(RoughnessProfile)
```

---

## BPTT (Backpropagation Through Time)

### ComputeBPTTGradients()

Truncated BPTT for training temporal networks.

**Physics:**
```
∂L/∂θ = Σ_t ∂L/∂a_t × ∂a_t/∂θ
Clipped: clip(∂L, -clip_val, +clip_val)
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `BPTT_windowSize` | int | - | 100 | Truncation window T |
| `BPTT_clipGrad` | float | - | 1.0 | Gradient clipping value |

**Usage:**
```go
EnableBPTT()
BPTT_windowSize = 50
BPTT_clipGrad = 5.0

// Training loop
for step := 0; step < 1000; step++ {
    // Forward pass
    ReservoirInput(input[step])
    Steps(1)

    // Record activation
    RecordBPTTActivation()

    // Backward pass every window
    if step % BPTT_windowSize == 0 {
        grads := ComputeBPTTGradients(target)
        ApplyGradients(grads, learningRate)
    }
}
```

---

## Spiking Neural Networks (LIF)

### UpdateSNN()

Leaky Integrate-and-Fire neuron dynamics.

**Physics:**
```
τ_m × dV/dt = -(V - V_rest) + R × I
if V > V_th: spike, V → V_reset, enter refractory
```

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `SNN_neuronCount` | int | - | 100 | Number of neurons |
| `SNN_tau` | float | s | 20e-3 | Membrane time constant |
| `SNN_Vth` | float | V | 1.0 | Spike threshold |
| `SNN_Vreset` | float | V | 0 | Reset potential |
| `SNN_Vrest` | float | V | 0 | Resting potential |
| `SNN_refractoryPeriod` | float | s | 2e-3 | Refractory period |

**Usage:**
```go
EnableSNN()
SNN_neuronCount = 256
SNN_tau = 10e-3
SNN_Vth = 1.0
SNN_refractoryPeriod = 1e-3

// Simulation loop
for t := 0.0; t < 1.0; t += dt {
    // Inject current
    SetSNNCurrent(inputCurrent)

    // Update neurons
    UpdateSNN()

    // Read spikes
    spikes := GetSNNSpikes()
}

// Get spike times
TableAdd(SNNSpikeTimes)
```

---

## Multi-Neuron Network

### SimulateNetwork()

Full network simulation with synaptic connections.

**Parameters:**

| Parameter | Type | Unit | Default | Description |
|-----------|------|------|---------|-------------|
| `Network_topology` | string | - | "random" | "random", "small-world", "scale-free" |
| `Network_connectivity` | float | - | 0.1 | Connection probability |
| `Network_synapticDelay` | float | s | 1e-3 | Axonal delay |

**Usage:**
```go
EnableNetworkSimulation()
Network_topology = "small-world"
Network_connectivity = 0.15
Network_synapticDelay = 2e-3

// Create network
CreateNetwork(256, Network_topology)

// Add STDP learning
EnableNetworkSTDP()

// Simulate
for epoch := 0; epoch < 100; epoch++ {
    PresentInput(pattern)
    SimulateNetwork(100e-3)  // 100 ms
}
```

---

## Spike Timing / Temporal Coding

### ComputeTemporalCode()

Latency-based temporal encoding.

**Physics:**
```
latency = t_first_spike - t_stimulus
code = 1 / latency (rate-to-time conversion)
```

**Usage:**
```go
EnableTemporalCoding()

// Present stimulus
PresentStimulus(input)

// Get temporal code
code := ComputeTemporalCode()

// Decode
output := DecodeTemporalPattern(code)
```

---

## SPICE Co-Simulation

### SetSPICENetlist()

Full SPICE netlist parser for circuit co-simulation.

**Supported Elements:**
- R (Resistor): `R1 node1 node2 1k`
- C (Capacitor): `C1 node1 node2 1p`
- V (Voltage source): `V1 node1 node2 DC 1.0`
- I (Current source): `I1 node1 node2 DC 1m`
- .SUBCKT (Subcircuit): `.SUBCKT name node1 node2 ...`

**Supported Suffixes:**
- T (10¹²), G (10⁹), M (10⁶), k (10³)
- m (10⁻³), u (10⁻⁶), n (10⁻⁹), p (10⁻¹²), f (10⁻¹⁵)

**Usage:**
```go
EnableSPICECoSim()

// Load netlist
SetSPICENetlist("mtj_circuit.cir")

// Or create programmatically
AddSPICEElement("R1", "IN", "MTJ", 1e3)
AddSPICEElement("C1", "MTJ", "GND", 1e-12)
AddSPICEElement("V1", "VDD", "GND", 1.0)

// Couple to magnetic simulation
CoupleSPICEtoRegion("MTJ", 1)

// Run co-simulation
SPICEStep(dt)
```

**Example Netlist (mtj_circuit.cir):**
```spice
* MTJ Read Circuit
V1 VDD GND DC 1.0
R1 VDD IN 1k
C1 IN GND 100f
.SUBCKT MTJ_DEVICE IN OUT
R_MTJ IN OUT 10k
.ENDS
X1 IN OUT MTJ_DEVICE
.END
```

---

## Complete V2.1 Example

```go
// Full multiscale simulation with SNN readout
SetGridSize(256, 256, 4)
SetCellSize(4e-9, 4e-9, 2e-9)

// Material
Msat = 1e6
Aex = 15e-12
alpha = 0.008
Ku1 = 0.6e6

// Grain structure
EnableGrainBoundaries()
GrainCount = 150
GrainBoundaryReduction = 0.4
GenerateVoronoiGrains(GrainCount)

// Defect pinning
EnableDynamicDefects()
DefectStrength = 0.15
GenerateRandomDefects(0.03)

// SAF coupling with temperature dependence
EnableRKKYCoupling()
EnableTemperatureRKKY()
SetRKKYStrength(-0.6e-3)
TempRKKY_Tc = 700

// Extended spin diffusion
EnableSpinDiffusionExtended()
SpinDiffusionExt_lambda = 6e-9
SpinDiffusionExt_omega = 1.6

// Orange-peel coupling
EnableOrangePeelGPU()
OrangePeel_Frms = 0.6e-9
OrangePeel_xi = 12e-9

// SNN readout
EnableSNN()
SNN_neuronCount = 64
SNN_tau = 15e-3

// SPICE circuit
EnableSPICECoSim()
SetSPICENetlist("readout_circuit.cir")

// Thermal
EnableThermalField()
Temp = 300

// Output
TableAdd(E_total)
TableAdd(SpinAccumulation)
TableAdd(SNNSpikeTimes)
TableAutosave(1e-12)

// Save grain structure
Save(GrainMap)
Save(DefectLocations)

// Simulate
Run(50e-9)

// Training with BPTT
EnableBPTT()
BPTT_windowSize = 20
BPTT_clipGrad = 2.0

for epoch := 0; epoch < 50; epoch++ {
    // Present input pattern
    B_ext = inputPattern[epoch]
    Run(1e-9)

    // Record and backprop
    RecordBPTTActivation()
    if epoch % 20 == 19 {
        grads := ComputeBPTTGradients(target)
        AdaptReservoirWeights(target)
    }
}
```

---

[Back to API Reference](/api/)
